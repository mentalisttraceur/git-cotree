#!/bin/sh -
# SPDX-License-Identifier: 0BSD
# Copyright 2021 Alexander Kozhevnikov <mentalisttraceur@gmail.com>

initialize()
{
    unused=`git log -n1` || return 1
    branch=`git branch --show-current` || return 1
    case $branch in '') error_not_on_branch; return 1; esac
    root=`git rev-parse --show-toplevel` || return 1
    cd "$root" || return 1
    case `git rev-parse --git-common-dir` in .git) :;; *)
        error_missing_git_directory; return 1
    esac
    git diff --staged --quiet
    case $? in 1)
        had_staged_changes=true
        git commit --quiet --message 'git-cotree temporary commit' || return 1
    esac
    git config --local core.bare true || return 1
    directory=`mktemp -d git-cotree-XXXXXX` || return 1
    chmod =rwx "$directory" || return 1
    git worktree add --no-checkout --quiet "$directory" "$branch" || return 1
    for name in * .*
    do
        case $name in "$directory" | .. | . | .git) :;; *)
            mv ./"$name" "$directory"/ || return 1
        esac
    done
    cd "$directory" || return 1
    git reset --quiet HEAD || return 1
    case $had_staged_changes in true)
        git reset --soft --quiet HEAD~1 || return 1
    esac
    cd "$root" || return 1
    case $branch in ?*/*)
        mkdir -p "${branch%/*}" || return 1
    esac
    git worktree move "$directory" "$branch" || return 1
}

create()
{
    case $# in 0) error_need_co_tree; return 1; esac
    root=`git rev-parse --git-common-dir`/.. || return 1
    root=`cd "$root" && pwd` || return 1
    directory=`_resolve_directory "$root" "$1"` || return 1
    case $# in 1)
        exec 3>&1
        unused=`git worktree add "$root/$directory" "$directory" 2>&1 1>&3` \
        || git worktree add "$root/$directory" -b "$directory" \
        || return 1
        return 0
    esac
    git worktree add "$root/$directory" -b "$directory" "$2" || return 1
}

delete()
{
    case $# in 0) error_need_co_tree; return 1; esac
    root=`git rev-parse --git-common-dir`/.. || return 1
    root=`cd "$root" && pwd` || return 1
    directory=`_resolve_directory "$root" "$1"` || return 1
    base=`git -C "$root" branch --show-current` || return 1
    branch=`git -C "$root/$directory" branch --show-current 2>/dev/null`
    git worktree remove $force "$root/$directory" || return 1
    current=`pwd` || return 1
    case "$root/$directory" in "$current"/?*) :;; *)
        cd "$root" || return 1
    esac
    while :
    do
        case $directory in */*)
            directory=${directory%/*}
            current=`pwd` || return 1
            case "$root/$directory" in "$current"/?*)
                if error=`rmdir "$root/$directory" 2>&1`
                then
                    continue
                else
                    if _directory_is_empty "$root/$directory"
                    then
                        printf '%s\n' "$error" 1>&2; return 1
                    fi
                    break
                fi
            esac
        esac
        break
    done
    case $branch in "$base") :;; ?*)
        git branch --delete $force "$branch" || return 1
    esac
}

_directory_is_empty()
{
    cd "$1" || return 1
    for file in *
    do
        case $file in '*') :;; *) return 1; esac
    done
    for file in ?
    do
        case $file in '?') :;; *) return 1; esac
    done
    for file in .*
    do
        case $file in . | ..) :;; *) return 1; esac
    done
    return 0
}

base()
{
    case $# in 0) error_need_co_tree; return 1; esac
    root=`git rev-parse --git-common-dir`/.. || return 1
    root=`cd "$root" && pwd` || return 1
    directory=`_resolve_directory "$root" "$1"` || return 1
    cd "$root" || return 1
    ref=refs/heads/$directory
    if git show-ref --verify --quiet "$ref"
    then
        git symbolic-ref HEAD "$ref" || return 1
        return 0
    fi
    error_not_a_branch "$directory"; return 1
}

_resolve_directory()
{
    directory=$2
    while :
    do
        case $directory in *//*)
            directory=${directory%%//*}/${directory#*//}
            continue
        esac
        break
    done
    case $directory in ../* | ./* | .. | .)
        while :
        do
            case $directory in
            ../* | ..)
                current=`pwd` || return 1
                case $current in "$1"/?*)
                    cd .. || return 1
                    directory=${directory#..}
                    directory=${directory#/}
                    continue
                esac
            ;;
            ./* | .)
                directory=${directory#.}
                directory=${directory#/}
                continue
            esac
            break
        done
        current=`pwd` || return 1
        case $current in "$1"/?*)
            directory=${current#"$1"/}/$directory
        esac
    esac
    directory=${directory%/}
    printf '%s\n' "$directory"
}

error_not_on_branch()
{
    printf '%s\n' 'fatal: must be on a branch' 1>&2
}

error_missing_git_directory()
{
    printf '%s\n' 'fatal: missing .git directory' 1>&2
}

error_not_a_branch()
{
    printf '%s\n' "fatal: not a branch: $1" 1>&2
}

error_need_co_tree()
{
    printf '%s\n' 'fatal: need co-tree argument' 1>&2
}

bad_option()
{
    printf '%s\n' "fatal: bad option: $1" 1>&2
}

help()
{
    printf '%s' \
'Usage:
    git-cotree <co-tree> [<commit-ish>]
    git-cotree --delete [--force] <co-tree>
    git-cotree --initialize
    git-cotree --base <co-tree>

Options:
    -h --help --usage       show this help text
    -i --init --initialize  set up for using co-trees
    -d --delete             delete this co-tree
    -f --force              force deleting this co-tree
    -D                      short for both --delete and --force
    -b --base               use this co-tree as the base branch
' || return 1
}

force=
action=create
for argument
do
    case $argument in
    -h | --help | --usage) help; exit $?;;
    -i | --init | --initialize) action=initialize;;
    -b | --base) action=base;;
    -d | --delete) action=delete;;
    -f | --force) force=--force;;
    -fd | -df | -D) force=--force && action=delete;;
    -*) bad_option "$1"; exit 1;;
    *) break;;
    esac
    shift 1
done
"$action" "$@"
