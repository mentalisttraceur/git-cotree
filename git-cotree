#!/bin/sh -
# SPDX-License-Identifier: 0BSD
# Copyright 2021 Alexander Kozhevnikov <mentalisttraceur@gmail.com>

arg0=$0

initialize()
{
    unused=`git log -n1` || exit 1
    branch=`git branch --show-current` || exit 1
    case $branch in '') error_not_on_branch; exit 1; esac
    root=`git rev-parse --show-toplevel` || exit 1
    cd "$root" || exit 1
    git diff --staged --quiet
    case $? in 1)
        had_staged_changes=true || exit 1
        git commit --quiet --message 'git-cotree temporary commit' || exit 1
    esac
    git diff --quiet
    case $? in 1)
        had_unstaged_changes=true || exit 1
        git stash --quiet || exit 1
    esac
    git rm -r --force --quiet --ignore-unmatch . || exit 1
    git config --local core.bare true || exit 1
    git worktree add --quiet "$branch" "$branch" || exit 1
    git worktree lock --reason 'co-tree base branch' "$branch" || exit 1
    cd "$branch" || exit 1
    case $had_staged_changes in true)
        git reset --quiet HEAD~1 || exit 1
        git add --all || exit 1
    esac
    case $had_unstaged_changes in true)
        git stash pop --quiet || exit 1
    esac
    cd "$root" || exit 1
    for untracked_file in * .*
    do
        case $untracked_file in "$branch" | .. | . | .git) :;; *)
            mv ./"$untracked_file" "$branch"/ || exit 1
        esac
    done
}

create()
{
    case $# in 0) error_need_directory; exit 1; esac
    directory=${1%/} || exit 1
    root=`git rev-parse --git-common-dir`/.. || exit 1
    root=`cd "$root" && pwd` || exit 1
    case $# in 1)
        exec 3>&1
        unused=`git worktree add "$root/$directory" "$directory" 2>&1 1>&3` \
        || git worktree add "$root/$directory" -b "$directory" \
        || exit 1
        exit 0
    esac
    git worktree add "$root/$directory" -b "$directory" "$2" || exit 1
}

delete()
{
    case $# in 0) error_need_directory; exit 1; esac
    directory=${1%/} || exit 1
    root=`git rev-parse --git-common-dir`/.. || exit 1
    root=`cd "$root" && pwd` || exit 1
    git worktree remove $force "$root/$directory" || exit 1
    if git show-ref --verify --quiet refs/heads/"$directory"
    then
        git branch --delete $force "$directory" || exit 1
    fi
    while :
    do
        case $directory in */*)
            directory=${directory%/*} || exit 1
            rmdir "$root/$directory" || exit 0
            continue
        esac
        break
    done
}

base()
{
    case $# in 0) error_need_directory; exit 1; esac
    directory=${1%/} || exit 1
    root=`git rev-parse --git-common-dir`/.. || exit 1
    cd "$root" || exit 1
    ref=refs/heads/$directory
    if git show-ref --verify --quiet "$ref"
    then
        previous=`git branch --show-current` || exit 1
        git worktree lock --reason 'co-tree base branch' "$directory" || exit 1
        printf '%s\n' "ref: $ref" >.git/HEAD || exit 1
        git worktree unlock "$previous" || exit 1
        exit 0
    fi
    error_not_a_branch "$directory"; exit 1
}

error_not_on_branch()
{
    printf '%s\n' "$arg0: must be on a branch" 1>&2
}

error_not_a_branch()
{
    printf '%s\n' "$arg0: not a branch: $1" 1>&2
}

error_need_directory()
{
    printf '%s\n' "$arg0: need directory" 1>&2
}

bad_option()
{
    printf '%s\n' "$arg0: bad option: $1" 1>&2
}

help()
{
    echo \
'Usage:
    git-cotree <directory> [<commit-ish>]
    git-cotree --delete [--force] <directory>
    git-cotree --initialize
    git-cotree --base <directory>

Options:
    -h --help --usage       Show this help text.
    -i --init --initialize  Set up the repository for co-trees.
    -d --delete             Delete a co-tree. This tries deleting
                            both the worktree and the branch.
    -f --force              Force deleting the co-tree branch,
                            even if there are unmerged changes.
    -D                      Short for both --delete and --force.
    -b --base               Change the co-tree base branch.' \
    || exit 1
}

force=
action=create
for argument
do
    case $argument in
    -h | --help | --usage) help; exit $?;;
    -i | --init | --initialize) action=initialize || exit 1;;
    -b | --base) action=base || exit 1;;
    -d | --delete) action=delete || exit 1;;
    -f | --force) force=--force || exit 1;;
    -fd | -df | -D) force=--force && action=delete || exit 1;;
    -*) bad_option "$1"; exit 1;;
    *) break;;
    esac
    shift 1
done
"$action" "$@"
